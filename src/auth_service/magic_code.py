"""
CherryPi Auth Service - Magic Code Manager

Handles generation, storage, and verification of magic codes for QR login.
Magic codes are stored in Redis with a 5-minute TTL.
"""

import logging
import os
import secrets
import string
from datetime import datetime
from typing import Optional, Dict

logger = logging.getLogger('auth_service.magic_code')

# Magic code configuration
MAGIC_CODE_LENGTH = 8
MAGIC_CODE_TTL = 300  # 5 minutes in seconds
MAGIC_CODE_PREFIX = 'magic_code:'


def generate_code(length: int = MAGIC_CODE_LENGTH) -> str:
    """Generate a random alphanumeric code (easy to type)."""
    # Use only uppercase and digits, avoiding confusing characters (0, O, I, 1, L)
    alphabet = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789'
    return ''.join(secrets.choice(alphabet) for _ in range(length))


class MagicCodeManager:
    """
    Manages magic codes for QR-based login.
    
    Magic codes are stored in Redis with format:
    magic_code:<code> -> JSON {created_by, created_at, role}
    
    Codes expire after 5 minutes (TTL).
    """
    
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def generate_code(self, created_by: str, target_role: str = 'guest') -> str:
        """
        Generate a new magic code.
        
        Args:
            created_by: Username of the admin creating the code
            target_role: Role to assign to the device (user or guest)
            
        Returns:
            The generated code string
        """
        import json
        
        # Generate unique code
        code = generate_code()
        
        # Ensure uniqueness (very unlikely collision, but check anyway)
        key = f"{MAGIC_CODE_PREFIX}{code}"
        while self.redis.exists(key):
            code = generate_code()
            key = f"{MAGIC_CODE_PREFIX}{code}"
        
        # Store code data
        data = {
            'created_by': created_by,
            'created_at': datetime.utcnow().isoformat(),
            'target_role': target_role
        }
        
        self.redis.setex(key, MAGIC_CODE_TTL, json.dumps(data))
        
        logger.info(f"Magic code generated by '{created_by}' (expires in {MAGIC_CODE_TTL}s)")
        
        return code
    
    def verify_and_burn(self, code: str) -> Optional[Dict]:
        """
        Verify a magic code and consume it (one-time use).
        
        Args:
            code: The magic code to verify
            
        Returns:
            Code data if valid, None if invalid/expired
        """
        import json
        
        code = code.upper().strip()
        key = f"{MAGIC_CODE_PREFIX}{code}"
        
        # Get and delete atomically using a transaction
        pipe = self.redis.pipeline()
        pipe.get(key)
        pipe.delete(key)
        results = pipe.execute()
        
        data_str = results[0]
        
        if not data_str:
            logger.warning(f"Invalid or expired magic code attempted")
            return None
        
        try:
            data = json.loads(data_str)
            logger.info(f"Magic code verified and burned")
            return data
        except json.JSONDecodeError:
            logger.error(f"Corrupted magic code data")
            return None
    
    def is_valid(self, code: str) -> bool:
        """Check if a magic code exists without consuming it."""
        code = code.upper().strip()
        key = f"{MAGIC_CODE_PREFIX}{code}"
        return self.redis.exists(key) > 0
    
    def get_ttl(self, code: str) -> int:
        """Get remaining TTL for a code in seconds."""
        code = code.upper().strip()
        key = f"{MAGIC_CODE_PREFIX}{code}"
        ttl = self.redis.ttl(key)
        return max(0, ttl)
